<?php
/*
 * parser.php
 * Parses an input file and replaces its short-form citations with longer citations generated by the Catalog system.
 * TODO: Needs to be fully OOP
 */
// TODO: check mode validity
require_once(__DIR__ . "/../Common/common.php");
require_once(BPATH . "/Catalog/load.php");
class Citation {
	public $handle; // handle for this citation in the ArticleList
	public $text; // text of the citation
	public $long; // long-form text
	public $url; // url for Wikipedia citation
	public $sfn; // sfn for the citation
	public $p; // |p= parameter for sfn
	public $pp; // |pp=
	public $loc; // |loc=
	public $refname; // automatically generated refname
	function __toString() {
		return $this->text;
	}
	function __construct($text, $paras = array()) {
		$this->text = $text;
		foreach($paras as $key => $value) {
			if($value) $this->$key = $value;
		}
	}
	function getsfn() {
		if(!$this->sfn) {
			if(!$this->handle) {
				echo 'Could not retrieve sfn (no handle)' . PHP_EOL;
				return false;
			}
			$this->sfn = CsvArticleList::singleton()->getsfn($this->handle);
		}
		$out = substr($this->sfn, 0, -2);
		if($this->p) $out .= '|p=' . $this->p;
		if($this->pp) $out .= '|pp=' . $this->pp;
		if($this->loc) $out .= '|loc=' . $this->loc;
		return $out . '}}';
	}
	function getrefname() {
		if(!$this->refname) {
			if(!$this->handle) {
				echo 'Could not retrieve refname (no handle)' . PHP_EOL;
				return false;
			}
			$this->refname = 
				CsvArticleList::singleton()->getrefname($this->handle);
			if(!$this->refname) {
				echo 'Could not retrieve refname' . PHP_EOL;
				return false;
			}
		}
		return $this->refname;
	}
}
class Parser extends ExecuteHandler {
	public $input; // string: input text. Parser::parse() may edit this text.
	public $result; // string: resulting (parsed) text.
	public $refs; // refs found in input
	function __construct($mode, $paras = '') {
		$this->mode = $mode;
		if(is_array($paras)) foreach($paras as $key => $para) {
			if(property_exists($this, $key)) $this->$key = $para;
		}
	}
	function parse($in) {
	// legacy
		$this->__invoke($in);
	}
	function __invoke($in) {
		/*
		 * prepare for parsing
		 */
		$this->refs = array();
		$csvlist = CsvArticleList::singleton();
		$this->result = $this->input = $in;
		$this->getcitetype();
		$csvlist->verbosecite = true;
		$this->usemode();
		/*
		 * do the actual parsing
		 */
		// make array of refs with corresponding citation
		preg_match_all("/(?<=\{)(?<!\{\{)(?![{|]).*?(?=\})/", $in, $cites);
		foreach($cites[0] as $cite) {
			// if there is a { in here, it's not a cite, but a template, and we can ignore it
			if(strpos($cite, '{') !== false) continue;
			$citename = parsecite($cite, 'main');
			if($csvlist->has($citename)) {
				// there is already a citation
				$this->refs[$cite] = $this->cite($cite);
			} else {
				$cmd = $this->menu(array(
					'head' => 'Source not found: ' . $citename,
					'options' => array(
						'' => 'add source',
						'q' => 'quit adding sources',
						'r' => 'make into redirect',
						'i' => 'ignore this citation',
					),
				));
				switch($cmd) {
					case 'q': 
						$this->shutdown();
					case 'r':
						if(!$csvlist->add_redirect(array('handle' => $citename)))
							$this->shutdown();
						$this->refs[$cite] = $this->cite($target);
						break;
					case 'i': 
						continue 2;
					case '':
						if($csvlist->addEntry(
							new Article($citename, 'n', $csvlist), 
							array('isnew' => true)
						)) {
							$this->refs[$cite] = $this->cite($cite);
						}
						else {
							echo 'Could not resolve source: ' . $citename . PHP_EOL;
						}
						break;
				}
			}
		}
		$this->replacecites();
		$this->refsort();
		$this->echolong();
		$this->makereflist();
		switch($this->mode) {
			case 'wlist': // used in 'parse -w': just return wiki-style list of refs
				$out = '';
				foreach($this->refs as $ref)
					$out .= '*' . $ref->text . PHP_EOL;
				return $out;
			case 'sep': // used for papers
				$out = array();
				$out[] = $this->result;
				if($this->refs) foreach($this->refs as $ref)
					$out[] = $ref->text;
				return $out;
			case 'wref':
				$this->result = wikify($this->result);
				return $this->result;
			case 'wtext':
				$this->applysfnm();
				return $this->result;
			case 'paper':
			case 'refend':
			case 'simple':
				return $this->result;
		}
	}
	function getcitetype() {
		preg_match('/<!--CITETYPE (.*?)-->/', $this->input, $matches);
		$csvlist = CsvArticleList::singleton();
		if(isset($matches[1])) {
			$csvlist->citetype = $matches[1];
		} elseif(!isset($csvlist->citetype)) {
			$csvlist->citetype = 'paper';
		}
	}
	public $mode; // string: parsing mode
	public $includesfn; // bool: whether or not Sfn should be included in short-form citations
	public function usemode() {
		$csvlist = CsvArticleList::singleton();
		switch($this->mode) {
			case 'wlist':
				$this->replacement = 1;
				$this->needsort = true;
				$csvlist->includesfn = true;
				break;
			case 'sep':
				$this->replacement = 2;
				$this->needsort = true;
				$csvlist->includesfn = false;
				break;
			case 'wref':
				$this->replacement = 3;
				$this->needsort = false;
				$csvlist->includesfn = false;
				$csvlist->includerefharv = false;
				break;
			case 'wtext':
				$this->replacement = 4;
				$this->usereflist = true;
				$this->needsort = true;
				$csvlist->includesfn = true;
				$this->echolong = true;
				$csvlist->citetype = 'wp';
				$this->reflistbegin = '==References==' . PHP_EOL .
					'{{reflist|colwidth=30em}}' . PHP_EOL .
					'===Literature cited===' . PHP_EOL;
				break;
			case 'paper':
				$this->replacement = 2;
				$this->usereflist = true;
				$this->needsort = true;
				$csvlist->includesfn = false;
				break;
			case 'refend':
				$this->replacement = 2;
				$this->reflistbegin = PHP_EOL . "\tReferences:" . PHP_EOL;
				$this->usereflist = true;
				$this->needsort = true;
				$this->liststyle = 2;
				$csvlist->citetype = 'paper';
				break;
			case 'simple':
				$this->replacement = 5;
				$csvlist->citetype = 'paper';
				break;
			default:
				echo 'Unrecognized mode: ' . $this->mode . PHP_EOL;
				break;
		}
		if(!isset($this->liststyle)) switch($csvlist->citetype) {
			case 'wp': case 'normal': 
				$this->liststyle = 1; 
				break;
			default: 
				$this->liststyle = 0; 
				break;
		}

	}
	public $resolveredirects; // bool: whether self::input should be edited to resolve redirects
	function cite($cite) {
		$csvlist = CsvArticleList::singleton();
		$c = parsecite($cite);
		$tmp = $csvlist($c['main']);
		if(is_array($tmp)) {
		// if we use cite doi etc, write the long-form citation into $this->longrefs
			$text = $tmp[0];
			$template = substr($text, 7, 3);
			if(in_array($template, array('hdl', 'jst', 'doi', 'pmc', 'pmi')))
				$url = $csvlist->get_citedoiurl($c['main'], $template);
			$long = $tmp[1];
		} else {
			$text = $tmp;
		}
		if($this->resolveredirects and $csvlist->isredirect($cite)) {
			$replace = '{' . $csvlist->resolve_redirect($c['main']);
			if(isset($c['p'])) $replace .= '|p=' . $c['p'];
			if(isset($c['pp'])) $replace .= '|pp=' . $c['pp'];
			if(isset($c['loc'])) $replace .= '|loc=' . $c['loc'];
			$replace .= '}';
			$this->input = str_replace('{' . $cite . '}', $replace, $this->input);
		}
		$citearray = array();
		if(isset($c['main'])) $citearray['handle'] = $c['main'];
		if(isset($c['p'])) $citearray['p'] = $c['p'];
		if(isset($c['pp'])) $citearray['pp'] = $c['pp'];
		if(isset($c['loc'])) $citearray['loc'] = $c['loc'];
		if(isset($long)) $citearray['long'] = $long;
		if(isset($url)) $citearray['url'] = $url;
		if(isset($sfn)) $citearray['sfn'] = $sfn;
		return new Citation($text, $citearray);
	}
	public $replacement; // int: what {cites} get replaced with. 1 = do nothing, leave them as they are; 2 = nothing; 3 = full ref; 4 = Sfn; 5 = just the ref text
	function replacecites() {
		if($this->replacement === 1) return;
		// work around because we can't use $this in the closure
		$refs = $this->refs;
		$replacement = $this->replacement;
		$this->result = preg_replace_callback(
			"/(?<!\{)\{(?![{|])(.*?)\}/",
			function($matches) use($refs, $replacement) {
				if(!$refs[$matches[1]])
					return $matches[0];
				$ref = $refs[$matches[1]];
				switch($replacement) {
					case 1: return $matches[0];
					case 2: return '';
					case 3: return "<ref name='" . $ref->getrefname() . "'>"  . $ref->text . '</ref>';
					case 4: return $ref->getsfn();
					case 5: return $ref->text;
				}
			},
			$this->result
		);
	}
	public $needsort; // sort the refs array?
	function refsort() {
		if(!($this->needsort and is_array($this->refs))) return;
		usort($this->refs, array($this, 'refsort_cb'));
	}
	function refsort_cb($a, $b) {
		return strnatcmp($a->text, $b->text);
	}
	public $echolong;
	function echolong() {
		if(!$this->echolong) return;
		if(!is_array($this->refs)) return;
		foreach($this->refs as $ref) {
			if($ref->long) echo $ref->url . PHP_EOL . $ref->long . PHP_EOL;
		}
	}
	public $usereflist = false; // bool: whether or not to place references in a list at the end
	public $reflistbegin = ''; // string: gets inserted at beginning of reflist
	public $reflistend = ''; // string: same, at end
	public $liststyle; // list style to use: 0 = html; 1 = wiki; 2 = text
	function makereflist() {
		if(!$this->usereflist) return;
		$replacement = $this->reflistbegin;
		// weed out duplicates called with different Sfns
		$refs = array();
		if(is_array($this->refs)) {
			foreach($this->refs as $ref)
				$refs[$ref->handle] = $ref->text;
		}
		foreach($refs as $ref) {
			switch($this->liststyle) {
				case 0: $replacement .= '<div class="references-item">'; break;
				case 1: $replacement .= '*'; break;
				case 2: $replacement .= "\t\t"; break;
			}
			$replacement .= $ref;
			switch($this->liststyle) {
				case 0: $replacement .= "</div>\n"; break;
				case 1: case 2: $replacement .= "\n"; break;
			}
		}
		$replacement .= $this->reflistend;
		$toreplace = $this->usereflist ? '/<references ?\/>/u' : '/$/u';
		$this->result = preg_replace($toreplace, $replacement, $this->result, 1);
	}
	function applysfnm() {
		$this->result = preg_replace_callback(
			'/(\{\{Sfn\|[^}]*?\}\}){2,}/u',
			function($matches) {
				$sfns = preg_split('/(?<=\}\})(?=\{\{)/u', $matches[0]);
				$osfns = array();
				foreach($sfns as $key => $sfn) {
					$paras = explode('|', substr($sfn, 5, -2));
					$osfns[$key] = array();
					foreach($paras as $pkey => $para) {
						if(strpos($para, '=') !== false) {
							$para = explode('=', $para);
							$osfns[$key][$para[0]] = $para[1];
						}
						else if(preg_match('/^\d{4}$/', $para))
							$osfns[$key]['year'] = $para;
						else if($para)
							$osfns[$key]['a' . $pkey] = $para;
					}
				}
				$out = '{{Sfnm';
				foreach($osfns as $key => $sfn) {
					foreach($sfn as $pkey => $para) {
						if($pkey[0] === 'a') {
							if($pkey === 'a1')
								$out .= '|' . $para;
							else
								$out .= '|' . ($key + 1) . $pkey . '=' . $para;
						}
					}
					$out .= '|' . $sfn['year'];
					foreach(array('p', 'pp', 'loc') as $pname) {
						if(isset($sfn[$pname]))
							$out .= '|' . ($key + 1) . $pname . '=' . $sfn[$pname];
					}
				}
				$out .= '}}';
				return $out;
			},
			$this->result
		);
	}
	function shutdown() {
		CsvArticleList::singleton()->saveIfNeeded();
		exit;
	}
}
function parsecite($in, $part = '') {
// this parses a cite of the form "Agathaeromys nov.pdf|p=9".
// @ return array with the pieces of the cite if $part unspecified
// @ return string if $part is specified and is 'main' or a parameter of the cite call
	$split = explode('|', $in);
	foreach($split as $key => $piece) {
		if($key === 0) {
			$out['main'] = $piece;
			continue;
		}
		$piece = explode('=', $piece);
		if(!isset($piece[1])) continue;
		$out[$piece[0]] = $piece[1];
	}
	if($part && $out[$part])
		return $out[$part];
	return $out;
}
function parse_wlist($in) {
	// make possible call from callfunc
	if(is_array($in)) {
		$in = $in[0];
	} elseif(!is_string($in)) {
		echo 'parse_wlist: invalid input' . PHP_EOL;
		return false;
	}
	global $wlist_p;
	$csvlist = CsvArticleList::singleton();
	if(!$csvlist->citetype) {
		$csvlist->citetype = 'wp';
	}
	if(!$wlist_p) {
		$wlist_p = new Parser('wlist', array('echolong' => true));
	}
	echo 'REFERENCE LIST' . PHP_EOL . $wlist_p($in);
	return true;
}
function parse_paper($infile) {
	return fileparse('paper', $infile);
	global $paper_p;
	$csvlist = CsvArticleList::singleton();
	if(!$csvlist->citetype) {
		$csvlist->citetype = 'paper';
	}
	if(!($text = file_get_contents($infile))) {
		throw new EHException('Failed to open file', EHException::E_FATAL);
	}
	if(!$paper_p) {
		$paper_p = new Parser('paper');
	}
	$parsed = $paper_p($text);
	$newname = str_replace('.', '-parsed.', $infile);
	file_put_contents($newname, $parsed);
	$n = escape_shell($newname);
	`open $n`;
}
function parse_wtext($infile) {
	return fileparse('wtext', $infile);
}
function fileparse($mode, $infile) {
	$pname = $mode . '_p';
	global ${$pname};
	if(!($text = @file_get_contents($infile))) {
		echo 'Failed to open file: ' . $infile . PHP_EOL;
		return false;
	}
	if(!${$pname}) ${$pname} = new Parser($mode);
	$parsed = ${$pname}($text);
	$newname = str_replace('.', '-parsed.', $infile);
	file_put_contents($newname, $parsed);
	$n = escape_shell($newname);
	shell_exec("edit " . $n);
	return $parsed;
}
