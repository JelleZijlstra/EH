<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>Introduction to EH</title>
	<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
	<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
	<script type="text/javascript" src="scripts/shBrushEh.js"></script>
	<script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<h1>Introduction to EH</h1>
<section id="intro">
<p>EH is a scripting language that I developed and implemented. It grew out of command-line interfaces that I developed for PHP objects representing (among others) citations to scientific articles, mammal species, and a Wikipedia bot. This interface initially allowed only for commands to be passed to the PHP objects (a command like <tt>bfind --authors='/Zijlstra/'</tt> would get interpreted into <tt>$this->bfind(array('authors' => '/Zijlstra/'));</tt>—a function that searches my bibliographic database). Later, I extended the PHP command-line interpreter to include features like variables, basic mathematics, functions, and loops. While this PHP tool, based mostly on regular expressions, does its job correctly, it is limited to simple statements (it cannot parse an assignment like <tt>$ foo = 1 + 2 * 3</tt>) and lacks a proper grammar.</p>

<p>Therefore, I have re-implemented EH using the standard tools Flex and Bison and a C++ interpreter. This code is used to generate a standalone interpreter (<tt>ehi</tt>) as well as a PHP interface for the interpreter (<tt>ehphp.so</tt>), which supports execution of commands (see below) parsed in C++ using PHP code. (I also started work on a native-code compiler, <tt>ehc</tt>, but it only ever supported a small subset of the language and I haven't maintained it when I updated the parser and other infrastructure shared with <tt>ehi</tt>.) <tt>ehi</tt> supports virtually all features of the PHP implementation, and adds many others, including classes, complex expressions, and type casting. By now, it has evolved so much that most of its features are incompatible with those of the PHP interpreter. Still, EH is a limited language, with a small standard library, a half-implemented object model, and an occasionally buggy interpreter. It is useful to me as a way to develop my coding skills and to make it easier to interface with PHP code for e.g. Catalog without modifying the PHP code itself.</p>

<p>This introduction documents the syntax of EH in the form supported by the C++ interpreter. Further examples of the language are in the <tt>test</tt> directory (which is also used to test <tt>ehi</tt> for regressions); these examples are referred to occasionally in this documentation.</p>

<p>But first, we'll need the obligatory first example of a programming language:</p>
<pre class="brush: eh;">
echo "Hello, world!"
</pre>
<p>That one could as well be a shell script; here is an object-oriented way to achieve the same goal:</p>
<pre class="brush: eh;">
class Printer {
	private msg
	public initialize = func: in {
		$this.msg = in
	}
	public print = func: {
		echo this.msg
	}
}
p = Printer.new: "Hello world"
$p.print:
</pre>
</section>
<section id="philosophy">
<h2>Basic features of the language</h2>
<p>EH has tended to absorb features of any language that I worked with and liked. When I started work on the language, C and PHP were pretty much the only languages I knew well, so the language was at first most similar to PHP in semantics. The original PHP interpreter operated in a similar way to assembly language. Later, I learned OCaml and Ruby, which inspired me to add more functional and object-oriented features. The object model also has a certain similarity to that of JavaScript.</p>

<p>EH is now an object-oriented language; every value is, at least theoretically, an object. All objects inherit implicitly from the base class <tt>Object</tt>. Expressions like <tt>3</tt>, <tt>"foo"</tt> or <tt>[1, 2]</tt> can be used to directly create instances of certain inbuilt classes (here, Integer, String, and Array), while other classes are created using the inherited method <tt>Object.new</tt>.</p>
</section>
<section id="syntax">
<h2>Syntax</h2>
<p>The EH syntax is vaguely similar to that of C-like languages, but there are some important differences. Parentheses are used only for grouping statements to remove ambiguity—structures like if conditions do not need parentheses, and function calls are implemented using the <tt>:</tt> (colon) operator instead. Code blocks can be delimited both with C-style curly braces and with the Ruby-like <tt>end</tt> keyword. Semicolons are not needed to terminate statements, but may be used to separate them. Comments may start with <tt>//</tt> or <tt>#</tt> and run to the end of the line.</p>

<p>The following code snippet demonstrates this syntax:</p>
<pre class="brush: eh;">
f1 = func: a {
	ret a * 1
}
f2 = func: a
	ret a * 2
end
# Semicolons can replace all newlines
f3 = func: a; ret a * 3; end
# Call f1, and dump the result
printvar: f1:
printvar: f2:
printvar: f3:
</pre>

<p>To understand other aspects of EH syntax and semantics, it is important to understand that virtually everything in EH is an operation on an object—even a variable assignment. Variables in the global scope are members of the global object, and local variables in a function are members of that function's <em>scope object</em> (which is accessible as the variable <tt>scope</tt>). An object has a <em>parent</em>, representing the object within which the object was declared, which is used for scope resolution: when the interpreter encounters a variable, it first looks for members of that name in the current scope object, then moves to the current scope's parent scope, and so on to the global scope.</p>
<p>A variable may be set with a statement like <tt>x = 1</tt>. However, if there is a global variable named <tt>x</tt>, this will change the value of the global. This can be avoided by explicitly declaring the variable as a member of the current object, with a syntax like <tt>private x = 1</tt>. Variables are referred to by their names (e.g., <tt>y = x</tt>); in some contexts a leading <tt>$</tt> may be used (e.g., <tt>y = $x</tt>).</p>
<p>Commands, which are used to interface with PHP, are now a somewhat detached part of the language. They are invoked by a bareword followed by a sequence of parameters, similar to parameters taken by command-line programs. In order to support commands, I have had to introduce several complications to the formal grammar, which cause some odd limitations.</p>

</section>
<section id="control-flow">
<h2>Control flow</h2>
</section>
<section id="inbuilt-types">
<h2>Inbuilt types</h2>
<p>For some object types, it is possible to create instances directly from literal values, instead of through method calls: <tt>Null</tt>, <tt>Bool</tt>, <tt>Float</tt>, <tt>Integer</tt>, <tt>String</tt>, <tt>Array</tt>, <tt>Function</tt>, <tt>Range</tt>, and <tt>Hash</tt>. These objects are constructed as follows:</p>
<dl>
<dt>Null</dt>
<dd>There is only one value of class <tt>Null</tt>, which is <tt>null</tt>. This value is returned when an operator does not explicitly return a value, and it is normally returned by library routines on failure.</dd>
<dt>Boolean</dt>
<dd>This class has two possible values, <tt>true</tt> and <tt>false</tt>.</dd>
<dt>Float</dt>
<dd>Floating-point values can be created using syntax like <tt>1.0</tt>.</dd>
<dt>Integer</dt>
<dd>Integers are created using syntax like <tt>42</tt>.</dd>
<dt>String</dt>
<dd>Strings may be declared using single (<tt>'a string'</tt>) or double (<tt>"a string"</tt>) quotes; there is no difference between these two.</dd>
<dt>Array</dt>
<dd>Arrays are most like PHP arrays, in that they map both strings and integers to arbitrary values. Arrays are declared like <tt>[0, 'foo' => 'bar', 3 => 42]</tt>. This array holds the values <tt>'bar'</tt> and <tt>42</tt> with the declared indices, and <tt>0</tt> with an index selected by the engine. <tt>Array</tt> supports <tt>operator-></tt> to access elements in the array (<tt>[0 => 1]->0 == 1</tt>) and <tt>operator->=</tt> to set elements (<tt>private a = [0 => 1, 1 => 2]; $a->0 = 3;</tt>).</dd>
<dt>Function</dt>
<dd>A function is a callable object; it implements <tt>operator:</tt> to produce a function call. Functions are declared (as detailed above) using several possible syntaxes; I normally use something like:
<pre class="brush: eh;">
private square = func: in {
	ret in * in
}
# @int 4
printvar: square: 2
</pre>
The <tt>ret</tt> keyword may be omitted, but this may lead to syntactic ambiguities with commands, and in some instances the engine does not recognize such an implicit return value and instead makes the function return <tt>null</tt>. If the function only returns a single expression, a special short syntax may be used:
<pre class="brush: eh;">
private square = func: in -> in * in
# @int 9
printvar: square: 3
</pre>
When a function is called, the object is instantiated and local variables are implemented as properties of that object. The object is exposed as the variable <tt>scope</tt>:
<pre class="brush: eh;">
private f = func: in {
	# currently, the scope variable probably has only one member: in
	private x = 3
	
	# now this returns @int 3
	printvar: scope.x
	
	$scope.x = 4
	
	# 4
	echo x
	ret scope
}
# returns a "function", but the function is an object with properties in and x
printvar: f: 42
</pre>
</dd>
<dt>Range</dt>
<dd>A range holds two values of the same type, normally integers. A range is declared like <tt>1..3</tt>. The values can be accessed using the <tt>Range.min</tt> and <tt>Range.max</tt> methods, or using <tt>operator-></tt> with index <tt>0</tt> and <tt>1</tt>.</dd>
<dt>Hash</dt>
<dd>A hash is a map from strings to arbitrary values. It is declared as <tt>{'foo' => 'bar', 'baz' => 'quux'}</tt> and accessed using <tt>operator-></tt> and <tt>operator->=</tt>, similar to an array.</dd>
</section>
<!--

\section{Types}
EH is dynamically typed; the type of a variable is decided at runtime and variables may change between types. 
%%
EH supports the following types:
\begin{itemize}
\item <tt>null</tt> A variable of this type has no value.
\item <tt>bool</tt> Boolean values: either <tt>true</tt> or <tt>false</tt>.
\item <tt>int</tt> Integers may be declared only in decimal notation (e.g., <tt>$ foo = 2</tt>).
\item <tt>string</tt> Strings may be declared enclosed in single or double quotes or, if they include only alphanumeric characters and underscores, without quotes. <tt>$ foo = "foo"</tt>, <tt>$ foo = 'foo'</tt>, and <tt>$ foo = foo</tt> will all work.
\item <tt>range</tt> Ranges: pairs of numbers representing a range. Ranges are declared in the form <tt>1..42</tt> and are useful mainly for use in <tt>for</tt> loops (see below).
\item <tt>float</tt> Floats (represented as 8-bit floating-point values). They are declared in decimal notation, e.g. <tt>$ pi = 3.14</tt>.
\item <tt>array</tt> Arrays.
\item <tt>func</tt> Functions.
\item <tt>object</tt> Objects.
\end{itemize}
Functions and objects are treated in more detail below.

Arrays can hold variables of any type and use indices that may be either integers or strings. 
%%
Access to an array uses the arrow operator <tt>-></tt>; <tt>$ foo -> 'bar' = 'baz'</tt> will place the string 'baz' in the array \$foo under the index 'bar'. 
%%
An array may be declared within square brackets; for example, <tt>$ foo = ['bar' => 'baz', 'spam' => 'eggs']</tt>. 
%%
The keys may also be omitted; in this case, numeric keys are automatically used.

The array access operator <tt>-></tt> may also be used with strings and integers, but only with integers keys. 
%%
For strings, it returns the ASCII value of the nth character in the string; for integers, it returns the value of the nth bit of the integer.

The type of an expression can be shown using the <tt>printvar:</tt> library function; for example, <tt>printvar: 3</tt> will print <tt>@int 3</tt>. 
%%
The method for typecasting an expression parallels <tt>printvar:</tt>'s output: for example, <tt>printvar: @string 3</tt> will show that the integer has been converted into a string containing the text '3'.

\section{Expressions}
EH expressions may include variable dereferences, mathematical operations, array declarations, function calls, and inline switch statements, among others. 
%%
An expression returns a value, which may be of any type.

Variables are dereferenced using a <tt>$</tt> without a succeeding space, followed by the variable's name.

The binary operators supported are <tt>+</tt> (addition and string concatenation), <tt>-</tt> (subtraction), <tt>*</tt> (multiplication), <tt>/</tt> (division), <tt>%</tt> (modulo), <tt>&</tt> (binary and), <tt>|</tt> (binary or), <tt>^</tt> (binary exclusive-or), <tt>=</tt> (equality; not assignment!), <tt>>=</tt>, <tt>></tt>, <tt><=</tt>, <tt><</tt>, <tt>!=</tt> (with the expected meanings), <tt>&&</tt> or <tt>and</tt> (logical and), <tt>||</tt> or <tt>or</tt> (logical or), and <tt>^^</tt> or <tt>xor</tt> (logical exclusive-or). 
%%
Unary operators include <tt>-</tt> (negation), <tt>~</tt> (bitwise negation), <tt>count</tt> (number of elements of an array, length of a string, size of an int), and <tt>!</tt> (boolean negation). 
%%
The logical \textit{and} and \textit{or} operators use short-circuit evaluation.

Operator precedence is generally sensible.
%%
If that is not enough, parentheses can be used to force a number of expressions together.

Inline switch statements use the <tt>given</tt> keyword and are useful as a concise version of a <tt>switch</tt>. 
%%
For example, one could write
\begin{verbatim}
echo given $argc
	case 1
		'I got one argument'
	case 2
		'I got two arguments'
	default
		'I got ' + (@string $argc) + ' arguments'
end
\end{verbatim}
The case labels may also be anonymous functions (see below).
%%
In this case, the function get executed with the switch variable (<tt>$argc</tt> in the example) as its only argument. 
%%
If it returns <tt>true</tt>, the case matches.
%%
See <tt>givenfunc.eh</tt> for an example of this feature.

\section{Control flow}
EH uses the control flow operators <tt>if</tt>, <tt>for</tt>, <tt>while</tt>, and <tt>switch</tt>.

The <tt>if</tt> and <tt>while</tt> operators are closely similar to those of other languages. 
%%
<tt>if</tt> is used like this:
\begin{verbatim}
if condition
	do stuff
else
	do other stuff
end
\end{verbatim}
The <tt>else</tt> part is optional.
%%
<tt>while</tt> is used like:
\begin{verbatim}
while condition
	do stuff
end
\end{verbatim}

There are four different kinds of <tt>for</tt> loops. 
%%
Loops of the form <tt>for expression; do stuff; end</tt> execute the number of times specified by the expression.
%%
If you add <tt>count</tt> followed by the name of a variable, the variable will hold the counter for the loop. 
%%
If the expression evaluates to a range, the counter will iterate from the lower to the upper end of that range (see <tt>eratosthenes2.eh</tt> for an example).
%%
A loop of the form <tt>for expression as variable; do stuff; end</tt> will iterate through the members of the array or object specified by the expression, putting the value of the member in <tt>variable</tt>.
%%
The label of the array or object member will also be put in a variable if the name of a second variable is specified following <tt>as</tt>, like <tt>for expression as key => value</tt> (see <tt>foras.eh</tt> for examples of this kind of loop).

In <tt>while</tt> and <tt>for</tt> loops, the keywords <tt>break</tt> and <tt>continue</tt> can be used to break out of a loop and continue with the next iteration, respectively.

<tt>switch</tt> works similarly to <tt>given</tt> discussed above, but differs in that its case blocks contain statements, not just expressions. 
%%
If a case block that matches the switch variable contains <tt>continue</tt>, the switch statement will also try to match other cases following the one executed (see <tt>switchcont.eh</tt>).

\section{Functions}

\section{Classes and objects}

\section{References}

\section{Commands}

\section{Standard library functions}

\end{document}
-->

</body>
</html>
