\documentclass{article}
\begin{document}
\title{An introduction to the EH scripting language}
\author{Jelle S. Zijlstra}
\maketitle
\tableofcontents
\pagebreak
\section{Introduction}
EH is a scripting language that I developed and implemented. 
%%
It grew out of command-line interfaces that I developed for PHP objects representing (among others) citations to scientific articles, mammal species, and a Wikipedia bot. 
%%
This interface initially allowed only for commands to be passed to the PHP objects (a command like \verb#bfind --authors='/Zijlstra/'# would get interpreted into \verb#$this->bfind(array('authors' => '/Zijlstra/'));#---a function that searches the Catalog bibliographic database). 
%%
Later, I extended the PHP command-line interpreter to include features like variables, basic mathematics, functions, and loops. 
%%
While this PHP tool, based mostly on regular expressions, does its job correctly, it is limited to simple statements (it cannot parse an assignment like \verb#$ foo = 1 + 2 * 3#) and lacks a proper grammar.

Therefore, I have re-implemented EH using the standard tools Flex and Bison and a C++ interpreter. 
%%
This code is used to generate a standalone interpreter (\verb#ehi#) as well as a PHP interface for the interpreter (\verb#ehphp#), which supports execution of commands (see below) parsed in C++ using PHP code. 
%%
(I also started work on a compiler, \verb#ehc#, but it only supports a small subset of the language.) 
%%
This implementation of EH supports virtually all features of the PHP implementation, and adds many others, including classes, complex expressions, and type casting.

Still, EH is a limited language, with a small standard library, no support for file I/O, and a constantly memory-leaking interpreter. 
%%
It is useful to me as a way to develop my coding skills and to make it easier to interface with PHP code for e.g. Catalog without modifying the PHP code itself.

This introduction documents the syntax of EH in the form supported by the C++ interpreter.
%%
Further examples of the language are in the \verb#EH-samples# directory; these examples are referred to occasionally in this documentation.

\section{Basic syntax}
EH is an imperative language, with syntax similar in many ways to languages like C. 
%%
However, it does not use curly braces, instead ending blocks with the \verb#end# keyword, and function calls use a colon instead of parentheses. 
%%
An EH program consists of statements, separated by either newlines or semicolons. 
%%
A statement may be a variable assignment, an expression, a command, the definition of a function or class, or any of various control flow structures. 
%%
With some exceptions, the number of spaces between operators is irrelevant.

Variable assignments take the form \verb#$ var = expression# (the space after the \$ is, in this case, essential), like this:
\begin{verbatim}
$ var = 2
echo $var
\end{verbatim}
This program will print 2. 
%%
Alternatively, \verb#set var = expression# or \verb#var := expression# may also be used for assignment.

Variables are scoped to either global scope or the function they are in. 
%%
Global variables are not automatically accessible from functions; to use a global variable within a function, it must be declared with the \verb#global# keyword. 
%%
The following program, which will print 42, provides an example:
\begin{verbatim}
$ var = 42
func printit:
	global var
	echo $var
end
printit:
\end{verbatim}

The \verb#echo# statement will print an arbitrary expression followed by a newline, and \verb#put# will do the same without the accompanying newline. 
%%
Both are neither functions nor commands, but core language constructs.

\section{Types}
EH is dynamically typed; the type of a variable is decided at runtime and variables may change between types. 
%%
EH supports the following types:
\begin{itemize}
\item \verb#null# A variable of this type has no value.
\item \verb#bool# Boolean values: either \verb#true# or \verb#false#.
\item \verb#int# Integers may be declared only in decimal notation (e.g., \verb#$ foo = 2#).
\item \verb#string# Strings may be declared enclosed in single or double quotes or, if they include only alphanumeric characters and underscores, without quotes. \verb#$ foo = "foo"#, \verb#$ foo = 'foo'#, and \verb#$ foo = foo# will all work.
\item \verb#range# Ranges: pairs of numbers representing a range. Ranges are declared in the form \verb#1..42# and are useful mainly for use in \verb#for# loops (see below).
\item \verb#float# Floats (represented as 8-bit floating-point values). They are declared in decimal notation, e.g. \verb#$ pi = 3.14#.
\item \verb#array# Arrays.
\item \verb#func# Functions.
\item \verb#object# Objects.
\end{itemize}
Functions and objects are treated in more detail below.

Arrays can hold variables of any type and use indices that may be either integers or strings. 
%%
Access to an array uses the arrow operator \verb#->#; \verb#$ foo -> 'bar' = 'baz'# will place the string 'baz' in the array \$foo under the index 'bar'. 
%%
An array may be declared within square brackets; for example, \verb#$ foo = ['bar' => 'baz', 'spam' => 'eggs']#. 
%%
The keys may also be omitted; in this case, numeric keys are automatically used.

The array access operator \verb#-># may also be used with strings and integers, but only with integers keys. 
%%
For strings, it returns the ASCII value of the nth character in the string; for integers, it returns the value of the nth bit of the integer.

The type of an expression can be shown using the \verb#printvar:# library function; for example, \verb#printvar: 3# will print \verb#@int 3#. 
%%
The method for typecasting an expression parallels \verb#printvar:#'s output: for example, \verb#printvar: @string 3# will show that the integer has been converted into a string containing the text '3'.

\section{Expressions}
EH expressions may include variable dereferences, mathematical operations, array declarations, function calls, and inline switch statements, among others. 
%%
An expression returns a value, which may be of any type.

Variables are dereferenced using a \verb#$# without a succeeding space, followed by the variable's name.

The binary operators supported are \verb#+# (addition and string concatenation), \verb#-# (subtraction), \verb#*# (multiplication), \verb#/# (division), \verb#%# (modulo), \verb#&# (binary and), \verb#|# (binary or), \verb#^# (binary exclusive-or), \verb#=# (equality; not assignment!), \verb#>=#, \verb#>#, \verb#<=#, \verb#<#, \verb#!=# (with the expected meanings), \verb#&&# or \verb#and# (logical and), \verb#||# or \verb#or# (logical or), and \verb#^^# or \verb#xor# (logical exclusive-or). 
%%
Unary operators include \verb#-# (negation), \verb#~# (bitwise negation), \verb#count# (number of elements of an array, length of a string, size of an int), and \verb#!# (boolean negation). 
%%
The logical \textit{and} and \textit{or} operators use short-circuit evaluation.

Operator precedence is generally sensible.
%%
If that is not enough, parentheses can be used to force a number of expressions together.

Inline switch statements use the \verb#given# keyword and are useful as a concise version of a \verb#switch#. 
%%
For example, one could write
\begin{verbatim}
echo given $argc
	case 1
		'I got one argument'
	case 2
		'I got two arguments'
	default
		'I got ' + (@string $argc) + ' arguments'
end
\end{verbatim}
The case labels may also be anonymous functions (see below).
%%
In this case, the function get executed with the switch variable (\verb#$argc# in the example) as its only argument. 
%%
If it returns \verb#true#, the case matches.
%%
See \verb#givenfunc.eh# for an example of this feature.

\section{Control flow}
EH uses the control flow operators \verb#if#, \verb#for#, \verb#while#, and \verb#switch#.

The \verb#if# and \verb#while# operators are closely similar to those of other languages. 
%%
\verb#if# is used like this:
\begin{verbatim}
if condition
	do stuff
else
	do other stuff
end
\end{verbatim}
The \verb#else# part is optional.
%%
\verb#while# is used like:
\begin{verbatim}
while condition
	do stuff
end
\end{verbatim}

There are four different kinds of \verb#for# loops. 
%%
Loops of the form \verb#for expression; do stuff; end# execute the number of times specified by the expression.
%%
If you add \verb#count# followed by the name of a variable, the variable will hold the counter for the loop. 
%%
If the expression evaluates to a range, the counter will iterate from the lower to the upper end of that range (see \verb#eratosthenes2.eh# for an example).
%%
A loop of the form \verb#for expression as variable; do stuff; end# will iterate through the members of the array or object specified by the expression, putting the value of the member in \verb#variable#.
%%
The label of the array or object member will also be put in a variable if the name of a second variable is specified following \verb#as#, like \verb#for expression as key => value# (see \verb#foras.eh# for examples of this kind of loop).

In \verb#while# and \verb#for# loops, the keywords \verb#break# and \verb#continue# can be used to break out of a loop and continue with the next iteration, respectively.

\verb#switch# works similarly to \verb#given# discussed above, but differs in that its case blocks contain statements, not just expressions. 
%%
If a case block that matches the switch variable contains \verb#continue#, the switch statement will also try to match other cases following the one executed (see \verb#switchcont.eh#).

\section{Functions}

\section{Classes and objects}

\section{References}

\section{Commands}

\section{Standard library functions}

\end{document}