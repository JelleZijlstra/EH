# Definition for the operations in EH bytecode.
# There are four registers (#0, #1, #2, #3) and a stack
# Code is organized in code objects, corresponding to .eh files. Each code
# object has a global registry of strings used in the file. Instructions
# with a string argument instead use an index into this registry.

# Code evaluation will proceed using frame object, essentially consisting of a reference
# to a code object and the location of the instruction pointer.

# TODO: Should opcodes imply their operands (e.g., JUMP_TRUE always uses #0) or include them as
# arguments (e.g., PUSH)? The former approach likely makes the bytecode interpreter faster (but
# how much?) and will make peephole optimizing code that reallocates registers easier to write.
# The latter approach makes it less often necessary to use MOVE in generated bytecode and may
# make for more sophisticated use of the registers.

const CODE_OBJECT_HEADER_SIZE = 20
const SIZEOF_OFFSET = 4
const SIZEOF_OPCODE = 8

ByteArray##wrappedSetInteger(loc, value) = do
    if !(value.isA Integer)
        throw(Exception(String value + " is not an integer"))
    end
    this.setInteger(loc, value)
end

enum Opcode
    JUMP(target), # unconditionally jumps to position target in the current code object
    JUMP_TRUE(target), # jumps to target if the current value in #0 is true
    JUMP_FALSE(target), # jumps to target if the current value in #0 is false
    JUMP_EQUAL(register_a, register_b, target), # jumps to target if register_a and register_b contain the same value
    MOVE(register_a, register_b), # moves a value from register a to register b
    LOAD(name), # looks up the value associated with the name and puts it in #0
    SET(attributes, name), # sets name to the value in #0 with the attributes given
    PUSH(register), # pushes the value in register n to the stack
    POP(register), # pops the value in register n off the stack
    CALL, # calls the object in #1 with the arguments in #0, putting the result in #0
    RETURN, # returns from the function with the value in #0
    LOAD_PROPERTY(name), # loads the property of #1 into #0
    SET_PROPERTY(attributes, name), # sets the property of #1 to #0
    LOAD_INSTANCE_PROPERTY(name), # loads the instance property of #1 to #0
    SET_INSTANCE_PROPERTY(attributes, name), # sets the instance property of #1 to #0
    CALL_METHOD(name), # calls the method named name of #1 with the arguments in #0
    LOAD_STRING(value), # load a constant with the given value into #0
    LOAD_INTEGER(value),
    LOAD_FLOAT(value),
    LOAD_TRUE(n), # load this value into register n
    LOAD_FALSE(n),
    LOAD_NULL(n),
    LOAD_THIS(n),
    LOAD_SCOPE(n),
    CREATE_TUPLE(n), # creates an empty tuple of size n and puts it in #2
    SET_TUPLE(n), # sets value n in a tuple literal in #2 to the value in #0
    GET_TUPLE(register_a, register_b, n), # puts the value in index n of the tuple literal in register_a into register_b
    CREATE_ARRAY(n), # creates an empty array of size n and puts it in #2
    SET_ARRAY(n), # sets value n in an array literal in #2 to the value in #0
    CREATE_MAP(n), # creates an empty map of size n and puts it in #2 (implementation will likely ignore n)
    SET_MAP(n), # sets value n in a tuple literal in #2 to the key in #0 and value in #1
    CREATE_RANGE, # creates a range object out of the objects in #0 (right end) and #1 (left end) and puts it in #2
    CREATE_FUNCTION(target), # creates a function object with code starting at target and puts it in #0
    CREATE_GENERATOR(target), # creates a generator object with code starting at target and puts it in #0
    LOAD_CLASS(target), # loads the class defined starting at target into #0. This will create a special frame terminated by an END_CLASS instruction
    CLASS_INIT(name), # sets the name of the class
    LOAD_ENUM(target), # loads an enum defined at target into #0
    ENUM_INIT(n, name), # sets the number of elements in the enum to n and the name to name. Enum size is limited to 65535 and each member can have up to 255 arguments.
    SET_ENUM_MEMBER(size, n, name), # sets enum member n to a member with name and size as given
    SET_ENUM_ARGUMENT(m, n, name), # sets argument m of member n to be named name
    GET_ENUM_ARGUMENT(register_a, register_b, n), # puts argument n of the enum instance in #a into #b
    HALT, # ends a class, enum, or module definition
    THROW_EXCEPTION(n), # throws an instance of the exception class with type_id n with the value in #0 as the argument
    THROW_VARIABLE(register), # throws the variable in register as an exception (useful for re-throwing)
    LOAD_RAW_INTEGER(n, value), # loads a raw integer with the given value into #n
    GET_RAW_TYPE(register_a, register_b), # loads the raw type_id of the value in register_a into register_b
    RAW_TUPLE_SIZE(register_a, register_b), # loads the size of the tuple in register_a into register_b as an integer
    MATCH_ENUM_INSTANCE(register_a, register_b, target), # matches the pattern in register_a (an enum constructor) against the variable in register_b (an enum instance) and if the match fails, jumps to target, else puts the size (number of arguments) of the constructor in #3
    BEGIN_TRY_FINALLY(target), # begins a try-finally block, with its finally block starting at target
    BEGIN_FINALLY, # begins the finally block
    END_TRY_FINALLY, # ends the finally block
    BEGIN_TRY_CATCH(target), # begins a try-catch statement. Always repeated: first instance indicates where the catch blocks starts and second where the subsequent code starts. If an exception is thrown, it will be put in #3 at the end of the block.
    END_TRY_BLOCK, # ends the try block in a try-catch
    BEGIN_CATCH, # begins a catch block
    END_TRY_CATCH, # ends the try-catch block
    YIELD(register), # yields the value in register
    POST_YIELD, # always follows YIELD; processes the message that comes in after a yield

    LABEL(n) # pseudo-opcode for a jump target (keep this last)
end

enum CAttributes
    Null, Set(is_private, is_static, is_const)

    public toInteger() = match this
        case Null
            0
        case Set(@is_private, _, @is_const)
            (is_private.toInteger() << 2) | (is_const.toInteger() << 1) | 1
    end

    public static parse attributes = do
        private parse_rec attributes = match attributes
            case Node.T_LIST(_) | Node.T_END
                [false, false, false]
            case Node.T_ATTRIBUTE(Attribute.constAttribute, @tail)
                private out = parse_rec tail
                out->2 = true
                out
            case Node.T_ATTRIBUTE(Attribute.staticAttribute, @tail)
                private out = parse_rec tail
                out->1 = true
                out
            case Node.T_ATTRIBUTE(Attribute.publicAttribute, @tail)
                private out = parse_rec tail
                out->0 = false
                out
            case Node.T_ATTRIBUTE(Attribute.privateAttribute, @tail)
                private out = parse_rec tail
                out->0 = true
                out
        end
        private lst = parse_rec attributes
        Set(lst->0, lst->1, lst->2)
    end
end

enum Option
    None, Some(value)
end
public None = Option.None
public Some = Option.Some

# round_up_to_multiple 15 4 = 16, 16 4 = 16
round_up_to_multiple m n = do
    whole = m / n
    mod = m % n
    if mod != 0
        whole += 1
    end
    whole * n
end

assert expr message = do
    if !expr
        throw(Exception message)
    end
end

class Label
    public initialize() = do
        private this.actual_location = null
    end

    public get_location() = this.actual_location

    public set_location location = do
        if this.actual_location != null
            throw(Exception "location already set")
        end
        this.actual_location = location
    end
end

class CodeObject
    public initialize() = do
        this.string_registry = {}
        this.next_string_index = CODE_OBJECT_HEADER_SIZE
        this.functions = []
        this.main_code = []
    end

    public register_string string = do
        if this.string_registry.has string
            this.string_registry->string
        else
            index = this.next_string_index
            len = string.length()
            # align to 4 bytes
            this.next_string_index += SIZEOF_OFFSET + round_up_to_multiple len SIZEOF_OFFSET
            this.string_registry->string = index
            index
        end
    end

    public register_function() = do
        private label = Label()
        private nco = NestedCodeObject this
        nco.append(Opcode.LABEL label)
        this.functions.append(nco.function_code)
        label, nco
    end

    public append opcode = this.main_code.append opcode

    # loads the code object into a binary string that can be passed to the bytecode interpreter
    public serialize() = do
        # first calculate the required size and the actual position of all labels created
        private code_offset = this.next_string_index
        private size = code_offset
        for fn in this.functions
            size = this.sizeof_code fn size
        end
        private entry_point = size
        size = this.sizeof_code (this.main_code) size

        # initialize the header
        private ba = ByteArray size
        echo size
        printvar ba
        echo(ba.length())
        ba->0 = 'E'.charAtPosition 0
        ba->1 = 'H'.charAtPosition 0
        ba->2 = 0
        ba->3 = 0
        ba.wrappedSetInteger(4, size)
        ba.wrappedSetInteger(8, CODE_OBJECT_HEADER_SIZE)
        ba.wrappedSetInteger(12, code_offset)
        ba.wrappedSetInteger(16, entry_point)

        # write the string registry
        for string, index in this.string_registry
            ba.wrappedSetInteger(index, string.length())
            content_index = index + SIZEOF_OFFSET
            for i in string.length()
                ba->(content_index + i) = string.charAtPosition i
            end
        end

        # write the code
        private offset = code_offset
        for fn in this.functions
            printvar fn
            offset = this.write_code ba offset fn
        end
        this.write_code ba offset (this.main_code)

        return ba
    end

    private write_code ba offset code = do
        for opcode in code
            match opcode
                case Opcode.LABEL(@label)
                    assert (label.get_location() != null) "label's location was not set"
                    continue
                case _
                    ()
            end
            ba->offset = opcode.numericValue()
            match opcode
                case Opcode.JUMP(@target) | Opcode.JUMP_TRUE(@target) | Opcode.JUMP_FALSE(@target) | Opcode.CREATE_FUNCTION(@target) | Opcode.LOAD_CLASS(@target) | Opcode.LOAD_ENUM(@target) | Opcode.BEGIN_TRY_FINALLY(@target) | Opcode.BEGIN_TRY_CATCH(@target) | Opcode.CREATE_GENERATOR(@target)
                    ba.wrappedSetInteger(offset + SIZEOF_OFFSET, target.get_location())
                case Opcode.MOVE(@register_a, @register_b) | Opcode.GET_RAW_TYPE(@register_a, @register_b) | Opcode.RAW_TUPLE_SIZE(@register_a, @register_b)
                    # offset + 1 is unused
                    ba->(offset + 2) = register_a
                    ba->(offset + 3) = register_b
                case Opcode.JUMP_EQUAL(@register_a, @register_b, @target) | Opcode.MATCH_ENUM_INSTANCE(@register_a, @register_b, @target)
                    ba->(offset + 2) = register_a
                    ba->(offset + 3) = register_b
                    ba.wrappedSetInteger(offset + SIZEOF_OFFSET, target.get_location())
                case Opcode.GET_TUPLE(@register_a, @register_b, @index) | Opcode.GET_ENUM_ARGUMENT(@register_a, @register_b, @index)
                    ba->(offset + 2) = register_a
                    ba->(offset + 3) = register_b
                    ba.wrappedSetInteger(offset + SIZEOF_OFFSET, index)
                case Opcode.LOAD(@name) | Opcode.LOAD_PROPERTY(@name) | Opcode.LOAD_INSTANCE_PROPERTY(@name) | Opcode.CALL_METHOD(@name) | Opcode.LOAD_STRING(@name) | Opcode.LOAD_INTEGER(@name) | Opcode.CLASS_INIT(@name)
                    ba.wrappedSetInteger(offset + SIZEOF_OFFSET, name)
                case Opcode.SET(@attributes, @name) | Opcode.SET_PROPERTY(@attributes, @name) | Opcode.SET_INSTANCE_PROPERTY(@attributes, @name)
                    ba->(offset + 2) = attributes.toInteger()
                    ba.wrappedSetInteger(offset + SIZEOF_OFFSET, name)
                case Opcode.PUSH(@register) | Opcode.POP(@register) | Opcode.LOAD_TRUE(@register) | Opcode.LOAD_FALSE(@register) | Opcode.LOAD_NULL(@register) | Opcode.LOAD_THIS(@register) | Opcode.LOAD_SCOPE(@register) | Opcode.THROW_VARIABLE(@register) | Opcode.YIELD(@register)
                    ba->(offset + 2) = register
                case Opcode.CALL | Opcode.RETURN | Opcode.CREATE_RANGE | Opcode.HALT | Opcode.BEGIN_FINALLY | Opcode.END_TRY_FINALLY | Opcode.BEGIN_CATCH | Opcode.END_TRY_CATCH | Opcode.END_TRY_BLOCK
                    ()
                case Opcode.LOAD_FLOAT(@value)
                    # TODO once we switch to double: use a separate float registry
                    float_bytes = value.toBytes()
                    for i in SIZEOF_OFFSET
                        ba->(offset + SIZEOF_OFFSET + i) = float_bytes->i
                    end
                case Opcode.CREATE_TUPLE(@n) | Opcode.SET_TUPLE(@n) | Opcode.CREATE_ARRAY(@n) | Opcode.SET_ARRAY(@n) | Opcode.CREATE_MAP(@n) | Opcode.SET_MAP(@n) | Opcode.THROW_EXCEPTION(@n)
                    ba->(offset + 2), ba->(offset + 3) = this.bytes_of_short n
                case Opcode.LOAD_RAW_INTEGER(@register, @value)
                    ba->(offset + 1) = register
                    ba.wrappedSetInteger(offset + SIZEOF_OFFSET, value)
                case Opcode.ENUM_INIT(@n, @value)
                    ba->(offset + 2), ba->(offset + 3) = this.bytes_of_short n
                    ba.wrappedSetInteger(offset + SIZEOF_OFFSET, value)
                case Opcode.SET_ENUM_MEMBER(@m, @n, @name) | Opcode.SET_ENUM_ARGUMENT(@m, @n, @name)
                    ba->(offset + 1) = m
                    ba->(offset + 2), ba->(offset + 3) = this.bytes_of_short n
                    ba.wrappedSetInteger(offset + SIZEOF_OFFSET, name)
            end
            offset += SIZEOF_OPCODE
        end
        return offset
    end

    private bytes_of_short n = do
        assert (n < 65536) "Cannot create literal with 65536 or more elements"
        private last_byte = n & 127
        private first_byte = (n >> 8) & 127
        # little-endian
        last_byte, first_byte
    end

    private sizeof_code code initial_size = do
        private size = initial_size
        for opcode in code
            match opcode
                case Opcode.LABEL(@label)
                    label.set_location size
                case _
                    size += SIZEOF_OPCODE
            end
        end
        size
    end
end

public disassemble ba = do
    private sb = String.Builder()
    private size = ba.getInteger 4
    private string_offset = ba.getInteger 8
    private code_offset = ba.getInteger 12
    private entry_point = ba.getInteger 16

    sb << "Header:\n"
    # TODO implement sprintf
    sb << "\tmagic=" << (ba->0).toChar() << (ba->1).toChar() << "\n"
    sb << "\tversion=" << ba->2 << "." << ba->3 << "\n"
    sb << "\tsize=" << size << "\n"
    sb << "\tstring_offset=" << string_offset << "\n"
    sb << "\tcode_offset=" << code_offset << "\n"
    sb << "\tentry_point=" << entry_point << "\n"
    sb << "Strings:\n"
    private offset = string_offset
    while offset < code_offset
        private string_length = ba.getInteger offset
        sb << "\t" << offset << " (" << string_length << ")"
        offset += SIZEOF_OFFSET
        for i in string_length
            sb << (ba->(offset + i)).toChar()
        end
        sb << "\n"
        offset += round_up_to_multiple string_length SIZEOF_OFFSET
    end
    sb << "Code:\n"
    while offset < size
        try
            opcode = Opcode.ofNumeric(ba->offset)
        catch if exception.isA ArgumentError
            opcode = '(unrecognized opcode: ' + String(ba->offset) + ')'
        end
        sb << "\t" << offset << " " << opcode << " (" << String(ba->offset) << "): "
        sb << ba->(offset + 1) << ", " << ba->(offset + 2) << ", " << ba->(offset + 3) << "; "
        sb << ba.getInteger(offset + 4) << "\n"
        offset += SIZEOF_OPCODE
    end

    sb.toString()
end

class NestedCodeObject
    public initialize(this.co) = do
        this.function_code = []
    end

    public append opcode = this.function_code.append opcode

    public register_string string = this.co.register_string string
    public register_function() = this.co.register_function()

    public contains_opcode needle = do
        for opcode in this.function_code
            echo(opcode, opcode.constructor(), needle, opcode.numericValue(), needle.numericValue())
            if opcode.numericValue() == needle.numericValue()
                echo "it matches"
                return true
            end
        end
        return false
    end
end

public compile code = do
    co = CodeObject()
    compile_rec code co
    co.append(Opcode.HALT)
    co.serialize()
end

private compile_rec code co = do
    if !(Node.isNode code)
        match code.type()
            case String
                string_id = co.register_string code
                co.append(Opcode.LOAD_STRING string_id)
            case Integer
                co.append(Opcode.LOAD_INTEGER code)
            case Float
                co.append(Opcode.LOAD_FLOAT code)
            case Bool
                private opcode = if code
                    Opcode.LOAD_TRUE
                else
                    Opcode.LOAD_FALSE
                end
                co.append(opcode 0)
            case Null
                co.append(Opcode.LOAD_NULL 0)
        end
        return
    end
    match code
        # Basic operations (variables, assignments, calls)
        case Node.T_CALL_METHOD(@obj, @method, @args)
            compile_rec obj co
            co.append(Opcode.PUSH 0)
            compile_rec args co
            co.append(Opcode.POP 1)
            method_id = co.register_string method
            co.append(Opcode.CALL_METHOD method_id)
        case Node.T_CALL(@function, @args)
            compile_rec function co
            co.append(Opcode.PUSH 0)
            compile_rec args co
            co.append(Opcode.POP 1)
            co.append(Opcode.CALL)
        case Node.T_VARIABLE(@name)
            name_id = co.register_string name
            co.append(Opcode.LOAD name_id)
        case Node.T_SEPARATOR(@lhs, @rhs)
            compile_rec lhs co
            compile_rec rhs co
        case Node.T_ASSIGN(@lvalue, @rvalue)
            compile_rec rvalue co
            compile_set lvalue co (CAttributes.Null)
        case Node.T_GROUPING(@val)
            compile_rec val co
        case Node.T_ACCESS(@base, @accessor)
            compile_rec base co
            co.append(Opcode.MOVE(0, 1))
            co.append(Opcode.LOAD_PROPERTY(co.register_string accessor))
        case Node.T_INSTANCE_ACCESS(@base, @accessor)
            compile_rec base co
            co.append(Opcode.MOVE(0, 1))
            co.append(Opcode.LOAD_INSTANCE_PROPERTY(co.register_string accessor))
        case Node.T_CLASS_MEMBER(@attributes, @lvalue)
            co.append(Opcode.LOAD_NULL 0)
            compile_set lvalue co (CAttributes.parse attributes)
        # Constants
        case Node.T_NULL
            co.append(Opcode.LOAD_NULL 0)
        case Node.T_THIS
            co.append(Opcode.LOAD_THIS 0)
        case Node.T_SCOPE
            co.append(Opcode.LOAD_SCOPE 0)
        # Control flow
        case Node.T_RET(@val)
            compile_rec val co
            co.append(Opcode.RETURN)
        case Node.T_BREAK(1)
            # TODO
            # sb << "ehval_p " << var_name << ";\nbreak"
        case Node.T_CONTINUE(1)
            # TODO
            # sb << "ehval_p " << var_name << ";\ncontinue"
        case Node.T_WHILE(@condition, @body)
            private begin_label = Label()
            private end_label = Label()
            co.append(Node.JUMP end_label)
            co.append(Node.LABEL begin_label)
            compile_rec body co
            co.append(Node.LABEL end_label)
            compile_rec condition co
            co.append(Node.JUMP_TRUE begin_label)
            # make sure while loop always returns null. Perhaps we can do without this.
            co.append(Node.LOAD_NULL 0)
        case Node.T_FOR(@iteree, @body)
            compile_for None iteree body co
        case Node.T_FOR_IN(@inner_var_name, @iteree, @body)
            compile_for (Some inner_var_name) iteree body co
        case Node.T_IF(@condition, @if_block, Node.T_LIST(@elsif_blocks))
            compile_elsifs condition if_block elsif_blocks () co
        case Node.T_IF_ELSE(@condition, @if_block, Node.T_LIST(@elsif_blocks), @else_block)
            compile_elsifs condition if_block elsif_blocks else_block co
        case Node.T_MATCH(@match_var, Node.T_LIST(@cases))
            private end_label = Label()
            private next_label = Label()
            compile_rec match_var co
            for kase in cases
                private next_label = Label()
                match kase
                    case Node.T_CASE(@pattern, @body)
                        compile_pattern pattern next_label co
                        compile_rec body co
                    case Node.T_WHEN(@pattern, @guard, @body)
                        compile_pattern pattern next_label co
                        compile_rec guard co
                        co.append(Opcode.JUMP_TRUE next_label)
                        compile_rec body co
                end
                co.append(Opcode.JUMP end_label)
                co.append(Opcode.LABEL next_label)
            end
            private message = "No matching case in match statement"
            co.append(Opcode.LOAD_STRING(co.register_string message))
            co.append(Opcode.THROW_EXCEPTION(RuntimeError.typeId()))
            co.append(Opcode.LABEL end_label)
        # Exceptions
        case Node.T_TRY(@try_block, Node.T_LIST(@catch_blocks))
            compile_try_catch try_block catch_blocks co
        case Node.T_TRY_FINALLY(@try_block, Node.T_LIST(@catch_blocks), @finally_block)
            private finally_label = Label()
            co.append(Opcode.BEGIN_TRY_FINALLY finally_label)
            compile_try_catch try_block catch_blocks co
            co.append(Opcode.BEGIN_FINALLY)
            co.append(Opcode.LABEL finally_label)
            co.append(Opcode.PUSH 0)
            compile_rec finally_block co
            co.append(Opcode.POP 0)
            co.append(Opcode.END_TRY_FINALLY)
        # Boolean operators
        case Node.T_AND(@left, @right)
            compile_rec left co
            private end_label = Label()
            co.append(Opcode.JUMP_FALSE end_label)
            compile_rec right co
            co.append(Opcode.LABEL end_label)
        case Node.T_OR(@left, @right)
            compile_rec left co
            private end_label = Label()
            co.append(Opcode.JUMP_TRUE end_label)
            compile_rec right co
            co.append(Opcode.LABEL end_label)
        case Node.T_XOR(@left, @right)
            # why is this an operator rather than a method on Object?
            private left_name = this.doCompile(sb, left)
            sb << "bool " << left_name << "_bool = eh_compiled::boolify(" << left_name << ", context, ehi)) {\n"
            private right_name = this.doCompile(sb, right)
            sb << "bool " << right_name << "_bool = eh_compiled::boolify(" << right_name << ", context, ehi)) {\n"
            sb << assignment << "Bool::make(" << left_name << "_bool != " << right_name << "_bool);\n"
        # Literals
        case Node.T_FUNC(@args, @code)
            private label, nco = co.register_function()
            compile_set args nco (CAttributes.Null)
            compile_rec code nco
            nco.append(Opcode.RETURN)
            if nco.contains_opcode(Opcode.YIELD)
                co.append(Opcode.CREATE_GENERATOR label)
            else
                co.append(Opcode.CREATE_FUNCTION label)
            end
        case Node.T_YIELD(@value)
            compile_rec value co
            co.append(Opcode.YIELD 0)
            co.append(Opcode.POST_YIELD)
        case Node.T_RANGE(@left, @right)
            compile_rec left co
            co.append(Opcode.PUSH 0)
            compile_rec right co
            co.append(Opcode.POP 1)
            co.append(Opcode.CREATE_RANGE)
            co.append(Opcode.MOVE(2, 0))
        case Node.T_HASH_LITERAL(Node.T_LIST(@hash))
            private size = hash.length()
            co.append(Opcode.CREATE_MAP size)
            i = 0
            for member in hash
                match member
                    case Node.T_ARRAY_MEMBER(@key, @value)
                        co.append(Opcode.PUSH 2)
                        compile_rec value co
                        co.append(Opcode.MOVE(0, 1))
                        co.append(Opcode.LOAD_STRING(co.register_string key))
                        co.append(Opcode.POP 2)
                        co.append(Opcode.SET_MAP i)
                end
                i += 1
            end
            co.append(Opcode.MOVE(2, 0))
        case Node.T_ARRAY_LITERAL(Node.T_LIST(@array))
            # reverse, because the parser produces them in reverse order
            private members = array.reverse()
            private size = members.length()
            co.append(Opcode.CREATE_ARRAY size)
            for i in size
                co.append(Opcode.PUSH 2)
                compile_rec (members->i) co
                co.append(Opcode.POP 2)
                co.append(Opcode.SET_ARRAY i)
            end
            co.append(Opcode.MOVE(2, 0))
        case Node.T_LIST(@items) # Tuple
            private size = items.length()
            co.append(Opcode.CREATE_TUPLE size)
            for i in size
                co.append(Opcode.PUSH 2)
                compile_rec (items->i) co
                co.append(Opcode.POP 2)
                co.append(Opcode.SET_TUPLE i)
            end
            co.append(Opcode.MOVE(2, 0))
        case ExtendedNode.T_MIXED_TUPLE_LIST(@items)
            private member_names = []
            private size = items.countWithPredicate(elt => match elt
                case Node.T_NAMED_ARGUMENT(_, _); false
                case _; true
            end)
            private twsk_name = this.get_var_name "twsk"
            sb << "auto " << twsk_name << " = new Tuple_WithStringKeys::t(" << size << ");\n"
            sb << assignment << "Tuple_WithStringKeys::make(" << twsk_name << ", ehi->get_parent());\n"
            private i = 0
            for item in items
                match item
                    case Node.T_NAMED_ARGUMENT(@name, @code)
                        private arg_name = this.doCompile(sb, code)
                        sb << twsk_name << '->set("' << name << '", ' << arg_name << ");\n"
                    case _
                        private arg_name = this.doCompile(sb, item)
                        sb << twsk_name << "->set(" << i << ", " << arg_name << ");\n"
                        i += 1
                end
            end
        case Node.T_ENUM(@enum_name, Node.T_LIST(@members), @body)
            private label, nco = co.register_function()
            private name_id = co.register_string enum_name

            co.append(Opcode.LOAD_ENUM label)
            co.append(Opcode.SET(CAttributes.Null, name_id))

            nco.append(Opcode.ENUM_INIT(members.length(), name_id))
            private i = 0
            # TODO: add an equivalent to Python's enumerate()
            for member in members
                match member
                    case Node.T_NULLARY_ENUM(@name)
                        nco.append(Opcode.SET_ENUM_MEMBER(0, i, co.register_string name))
                    case Node.T_ENUM_WITH_ARGUMENTS(@name, Node.T_LIST(@args))
                        nco.append(Opcode.SET_ENUM_MEMBER(args.length(), i, co.register_string name))
                        private j = 0
                        for arg in args
                            nco.append(Opcode.SET_ENUM_ARGUMENT(j, i, co.register_string arg))
                            j += 1
                        end
                    case Node.T_ENUM_WITH_ARGUMENTS(@name, @arg)
                        nco.append(Opcode.SET_ENUM_MEMBER(1, i, co.register_string name))
                        nco.append(Opcode.SET_ENUM_ARGUMENT(0, i, co.register_string arg))
                end
                i += 1
            end
            compile_rec body nco
            nco.append(Opcode.HALT)
        case Node.T_CLASS(@body)
            compile_class body (co.register_string "(anonymous class)") co
        case Node.T_NAMED_CLASS(@name, @body)
            name_id = co.register_string name
            compile_class body name_id co
            co.append(Opcode.SET(CAttributes.Null, name_id))
    end
end

private compile_elsifs condition if_block elsif_blocks else_block co = do
    compile_rec condition co
    private next_block = Label()
    private bottom = Label()
    co.append(Opcode.JUMP_FALSE next_block)
    compile_rec if_block co
    co.append(Opcode.JUMP bottom)
    co.append(Opcode.LABEL next_block)

    for elsif_block in elsif_blocks
        match elsif_block
            case Node.T_ELSIF(@elsif_condition, @elsif_body)
                next_block = Label()
                compile_rec elsif_condition co
                co.append(Opcode.JUMP_FALSE next_block)
                compile_rec elsif_body co
                co.append(Opcode.JUMP bottom)
                co.append(Opcode.LABEL next_block)
        end
    end
    if else_block != null
        compile_rec else_block co
    end

    co.append(Opcode.LABEL bottom)
end

private compile_class body name_id co = do
    private label, nco = co.register_function()
    co.append(Opcode.CLASS_INIT name_id)
    compile_rec body co
    co.append(Opcode.HALT)
end

# compiles a set-expression lvalue, assuming the rvalue is in #0
private compile_set code co attributes = match code
    case Node.T_NULL
        private safe_label = Label()
        co.append(Opcode.GET_RAW_TYPE(0, 1))
        co.append(Opcode.LOAD_RAW_INTEGER(2, null.typeId()))
        co.append(Opcode.JUMP_EQUAL(1, 2, safe_label))
        co.append(Opcode.LOAD_STRING(co.register_string "Expected a null value"))
        co.append(Opcode.THROW_EXCEPTION(RuntimeError.typeId()))
        co.append(Opcode.LABEL safe_label)
    case Node.T_ANYTHING
        # ignore
    case Node.T_ARROW(@base, @accessor)
        co.append(Opcode.PUSH 0)
        compile_rec base co
        co.append(Opcode.PUSH 0)
        compile_rec accessor co
        co.append(Opcode.CREATE_TUPLE)
        co.append(Opcode.SET_TUPLE 0)
        co.append(Opcode.POP 1)
        co.append(Opcode.POP 0)
        co.append(Opcode.SET_TUPLE 1)
        co.append(Opcode.MOVE(2, 0))
        co.append(Opcode.CALL_METHOD(co.register_string("operator->=")))
    case Node.T_ACCESS(@base, @accessor)
        co.append(Opcode.PUSH 0)
        compile_rec base co
        co.append(Opcode.MOVE(0, 1))
        co.append(Opcode.POP 0)
        co.append(Opcode.SET_PROPERTY(attributes, co.register_string accessor))
    case Node.T_INSTANCE_ACCESS(@base, @accessor)
        co.append(Opcode.PUSH 0)
        compile_rec base co
        co.append(Opcode.MOVE(0, 1))
        co.append(Opcode.POP 0)
        co.append(Opcode.SET_INSTANCE_PROPERTY(attributes, co.register_string accessor))
    case Node.T_VARIABLE(@name)
        co.append(Opcode.SET(attributes, co.register_string name))
    case Node.T_CLASS_MEMBER(@attributes_code, @lval)
        compile_set lval co (CAttributes.parse attributes_code)
    case Node.T_GROUPING(@lval)
        compile_set lval co attributes
    case Node.T_LIST(@vars)
        for i in vars.length()
            this.compile_set_list_member(sb, vars->i, i, name, attributes)
        end
    case ExtendedNode.T_MIXED_TUPLE_LIST(@vars)
        private i = 0
        for var in vars
            match var
                case Node.T_NAMED_ARGUMENT(@var_name, @dflt)
                    private na_var_name = this.get_var_name "na_var"
                    sb << "ehval_p " << na_var_name << ";\n"
                    sb << "if(ehi->call_method_typed<Bool>(" << name << ', "has", String::make(strdup("' << var_name << "\")), context)->get<Bool>()) {\n"
                    sb << na_var_name << " = ehi->call_method(" << name << ', "operator->", String::make(strdup("' << var_name << "\")), context);\n"
                    sb << "} else {\n"
                    private dflt_name = this.doCompile(sb, dflt)
                    sb << na_var_name << " = " << dflt_name << ";\n}\n"
                    sb << 'context.scope->set_member("' << var_name << '", ehmember_p('
                    if attributes == null
                        sb << "attributes_t::make_private()"
                    else
                        sb << attributes
                    end
                    sb << ", " << na_var_name << "), context, ehi);\n"
                case _
                    this.compile_set_list_member(sb, var, i, name, attributes)
                    i++
            end
        end
    case _
        printvar lvalue
        throw(NotImplemented "Cannot compile this lvalue")
end

private compile_pattern pattern next_label co = match pattern
    case Node.T_ANYTHING
        # do nothing, it's always true
    case Node.T_GROUPING(@inner)
        compile_pattern inner next_label co
    case Node.T_MATCH_SET(@name)
        # TODO ideally this shouldn't set the name if the match fails elsewhere
        private attributes = CAttributes.Set(true, false, false)
        co.append(Opcode.SET(attributes, co.register_string name))
    case Node.T_AS(@inner, @name)
        compile_pattern inner next_label co
        private attributes = CAttributes.Set(true, false, false)
        co.append(Opcode.SET(attributes, co.register_string name))
    case Node.T_BAR(@left, @right)
        private inner_next_label = Label()
        compile_pattern left inner_next_label co
        # if that one did not succeed, try the other one
        co.append(Opcode.LABEL inner_next_label)
        compile_pattern right next_label co
    case Node.T_LIST(@members)
        private members_size = members.length()
        # first check that the match var is a tuple
        co.append(Opcode.GET_RAW_TYPE(0, 2))
        co.append(Opcode.LOAD_RAW_INTEGER(Tuple.typeId(), 3))
        co.append(Opcode.JUMP_EQUAL(2, 3, next_label))
        co.append(Opcode.RAW_TUPLE_SIZE(0, 2))
        co.append(Opcode.LOAD_RAW_INTEGER(members_size, 3))
        co.append(Opcode.JUMP_EQUAL(2, 3, next_label))
        co.append(Opcode.PUSH 0)
        for i in members_size
            co.append(Opcode.POP 1)
            co.append(Opcode.GET_TUPLE(1, 0, i))
            co.append(Opcode.PUSH 1)
            compile_pattern (members->i) next_label co
        end
        co.append(Opcode.POP 0)
    case Node.T_CALL(@base, Node.T_GROUPING(@args))
        co.append(Opcode.PUSH 0)
        compile_rec base co
        co.append(Opcode.POP 1)
        co.append(Opcode.MATCH_ENUM_INSTANCE(0, 1, next_label))
        private args_size = match args
            case Node.T_LIST(@args_list); args_list.length()
            case _; 1
        end
        co.append(Opcode.LOAD_RAW_INTEGER(args_size, 2))
        private after_exception_label = Label()
        co.append(Opcode.JUMP_EQUAL(2, 3, after_exception_label))
        co.append(Opcode.LOAD_STRING(co.register_string "Invalid argument number in Enum.Member match"))
        co.append(Opcode.THROW_EXCEPTION(RuntimeError.typeId()))
        co.append(Opcode.LABEL after_exception_label)
        match args
            case Node.T_LIST(@args_list)
                co.append(Opcode.PUSH 1)
                for i in args_size
                    co.append(Opcode.POP 1)
                    co.append(Opcode.GET_ENUM_ARGUMENT(1, 0, i))
                    co.append(Opcode.PUSH 1)
                    compile_pattern (args_list->i) next_label co
                end
                co.append(Opcode.POP 0)
            case _
                co.append(Opcode.GET_ENUM_ARGUMENT(1, 0, 0))
                compile_pattern args next_label co
        end
    case _
        co.append(Opcode.PUSH 0)
        compile_rec pattern co
        co.append(Opcode.MOVE(0, 1))
        co.append(Opcode.POP 0)
        co.append(Opcode.CALL_METHOD(co.register_string "operator=="))
        co.append(Opcode.JUMP_FALSE next_label)
end

private compile_try_catch try_block catch_blocks co = if catch_blocks == Tuple []
    # simplify case where there are no catch blocks (e.g., in a try-finally)
    compile_rec try_block co
else
    private start_catch_label = Label()
    private end_try_catch_label = Label()
    co.append(Opcode.BEGIN_TRY_CATCH start_catch_label)
    co.append(Opcode.BEGIN_TRY_CATCH end_try_catch_label)
    compile_rec try_block co
    co.append(Opcode.END_TRY_BLOCK)
    co.append(Opcode.LABEL start_catch_label)

    for block in catch_blocks
        private next_label = Label()
        co.append(Opcode.BEGIN_CATCH)
        co.append(Opcode.PUSH 3)
        match block
            case Node.T_CATCH(@body)
                compile_rec body co
                co.append(Opcode.JUMP end_try_catch_label)
            case Node.T_CATCH_IF(@guard, @body)
                compile_rec guard co
                co.append(Opcode.JUMP_FALSE next_label)
                compile_rec body co
                co.append(Opcode.JUMP end_try_catch_label)
        end
        co.append(Opcode.LABEL next_label)
        co.append(Opcode.POP 3)
    end

    co.append(Opcode.THROW_VARIABLE 3)
    co.append(Opcode.END_TRY_CATCH)
    co.append(Opcode.LABEL end_try_catch_label)
end

private compile_for var_name iteree body co = do
    compile_rec iteree co
    co.append(Opcode.PUSH 0)
    co.append(Opcode.MOVE(0, 1))
    co.append(Opcode.LOAD_NULL 0)
    co.append(Opcode.CALL_METHOD (co.register_string "getIterator"))
    co.append(Opcode.PUSH 0)

    private begin_loop_label = Label()
    private end_loop_label = Label()
    private catch_label = Label()
    private end_catch_label = Label()
    private set_var_label = Label()

    co.append(Opcode.LABEL begin_loop_label)
    co.append(Opcode.POP 1)

    co.append(Opcode.BEGIN_TRY_CATCH catch_label)
    co.append(Opcode.BEGIN_TRY_CATCH end_catch_label)
    co.append(Opcode.LOAD_NULL 0)
    co.append(Opcode.CALL_METHOD (co.register_string "next"))
    co.append(Opcode.PUSH 1)
    co.append(Opcode.LOAD_RAW_INTEGER(2, 0))
    co.append(Opcode.END_TRY_BLOCK)
    co.append(Opcode.LABEL catch_label)
    co.append(Opcode.BEGIN_CATCH)
    co.append(Opcode.LOAD_RAW_INTEGER(2, 1))
    co.append(Opcode.END_TRY_CATCH)
    co.append(Opcode.LABEL end_catch_label)

    # we set #2 to 0 if the call to next succeeded and 1 if an exception was thrown
    # can't do the jumps inside the try-catch block because that's in its own function, and
    # we won't exit it if we simply jump
    co.append(Opcode.LOAD_RAW_INTEGER(1, 0))
    co.append(Opcode.JUMP_EQUAL(1, 2, set_var_label))

    # now there must be an active exception
    co.append(Opcode.GET_RAW_TYPE(3, 2))
    co.append(Opcode.LOAD_RAW_INTEGER(1, EmptyIterator.typeId()))
    co.append(Opcode.JUMP_EQUAL(1, 2, end_loop_label))
    co.append(Opcode.THROW_VARIABLE 3)

    co.append(Opcode.LABEL set_var_label)
    match var_name
        case None
            ()
        case Some(@ast)
            compile_set ast co (CAttributes.Null)
    end

    compile_rec body co

    co.append(Opcode.JUMP begin_loop_label)
    co.append(Opcode.LABEL end_loop_label)
    # NOTE: we may need to POP the iterator off the stack here. Currently
    # this is not necessary because the loop exit always goes through the
    # above try-catch block, where it is already popped, but if we add
    # support for break we'll have to POP it off explicitly.
    # for loops return the thing they're iterating over
    # this isn't very sensible behavior and maybe we should get rid of it
    co.append(Opcode.POP 0)
end
