For classes, we have a repository that, based on type_enum, holds information on classes. When a class is created, we assign it the next available number from the pool, and that number is what's actually stored in its object_data. We retire the classname. Operations like instanceof and context_compare can use the number.

There are four possible kinds of procedure calls:
- Library methods on pseudo-objects (e.g., "foo".length:)
- Library methods on actual objects (e.g., class Foo{}; Foo.new:)
- User methods on pseudo-objects (e.g. Array.size = func: -> self.length:)
- User methods on real objects (e.g. class Foo { public bar: { printvar: this; }}

In the second case, the library method should get the object in its context argument, and the object_data in its obj argument. This should also work with something like:
class Foo {
	private static count = 0
	public factory: {
		count = count + 1
		new:
	}
}
In that case, we should be smart enough to associate the context with the object. In fact, that would be done by using "bindings" more generally.

For the first case, we should send the library class itself as the context.

For user methods, we create a new context object with the object as a parent scope, and a convenience $this variable that refers to it, as well as a self variable representing this->object_data.


NEW FEATURE: Algebraic data types and pattern matching

Goal:

enum List
	Nil, Cons(Object, List)

	public reduce = base, f => given this
		case Nil
			base
		case Cons(hd, tl)
			f(hd, tl.reduce(base, f))
	end
end

- enum creates a special kind of class that inherits automatically from some special core class, and where the first line inside of the class includes the possible types.
- List.Nil is an object of type EnumMember
- Pattern match of var against Cons(hd, tl) would:
	- Check that var's class == Cons's class
	- Check that var's enum kind == Cons's
	- Check that arguments match and concurrently set variables like hd and tl.

Enum.initialize is const private, and instead the EnumMember serves as a constructor creating an underlying Enum object that contains the data.

Initialize with List.Cons(2, List.Cons(3, List.Nil)). And we could still do Object.operator:: = rhs => List.Cons(this, rhs).

So essentially, List.Nil should be a constant, but List.Cons a (constructor) function. Accomplish that by overloading operator() for some EnumMember instances.

OTHER THINGS TO DO
- Add something to ehobj_t so we can distinguish between classes and instances, and make static methods only callable in classes.
- Do something about the private-in-inherited-class bug.
